// Golang program online for dashboard API

package main

import "fmt"
import "os"
import "strings"
import "strconv"
import "context"
import "time"
import "encoding/json"
import "sync"
import "net/http"

type UserDetailsAndTodo struct
  {
    Id string `json:"id"`
    Full_name string `json:"full_name"`
    Status string `json:"status"`
    Pending_task_count string `json:"pending_task_count"`
    Next_urgent_task string `json:"next_urgent_task"`
    Error_warning string `json:"error_warning"`
  }
type userResult struct {
    userdata  []string
    founduser bool
    errfromfunc error
  }

var userinfo [][]string
var todoinfo [][]string

func main() {
 
  http.HandleFunc("/dashboard/", userHandler)
  httperror := http.ListenAndServe(":8080", nil)
  if (httperror != nil) {
      println ("Failed to start server, exiting...!!!")
      os.Exit(1);
  }
  
}

func userHandler(w http.ResponseWriter, r *http.Request) {
  var inpUserID string
  var udt []string
  var tds []string
  var foundudt, foundtds bool
  var errudt, errtds error
  var result UserDetailsAndTodo
  var udetails, utodos userResult
  var waitGrp sync.WaitGroup
    
  urlElement := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
  if len(urlElement) != 2 || urlElement[0] != "dashboard" {
    http.Error(w, "invalid path", http.StatusBadRequest)
    return
  }

  inpUserID = urlElement[1]  
  //inpUserID = "3"
  println ("\nThe User ID to get the data for details and Todo is : ", inpUserID)
  
  ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
  defer cancel()
  
  userinfo = readAndStoreUser(ctx, inpUserID)
  todoinfo = readAndStoreTodo(ctx, inpUserID)
  
    println ("\nExpected output of User data from the array:")
    println ("------------------------------------------------")
    if len(userinfo) > 0 {
        for i := 0; i < len(userinfo) ; i++ {
            for j := 0 ; j < len(userinfo[i]) ; j++ {
                print (userinfo[i][j],"#")
            }
            println ("")
        }
    } else {
           println ("Empty array for User details info due to Error encountered")
    }
  
    println ("\nExpected output of Todo data from the array:")
    println ("------------------------------------------------")
    if len(todoinfo) > 0 {
        for i := 0; i < len(todoinfo) ; i++ {
            for j := 0 ; j < len(todoinfo[i]) ; j++ {
                print (todoinfo[i][j],"#")
            }
            println ("")
        }
    } else {
           println ("Empty array for User Todos info due to Error encountered")
    }
  
  //Fetching the result using concurrent tasks starts here ensuring the task completion
  waitGrp.Add(2)

  go func() {
      defer waitGrp.Done()
      if len(userinfo) > 0 {
        udt, foundudt, errudt = findDetailsForUser(ctx,inpUserID,userinfo)
      } else {
          println ("Fetch for User Details info is not invoked due to no data...Concurrency Broken..!!!")
      }
  }()
  
  go func() {
    defer waitGrp.Done()
    if len(userinfo) > 0 {
        tds, foundtds, errtds = findTodoForUser(ctx,inpUserID,todoinfo)
    } else {
          println ("Fetch for User ToDos info is not invoked due to no data...Concurrency Broken..!!!")
      }
  }()
  
  waitGrp.Wait()
  
  udetails = userResult{udt, foundudt, errudt}
  utodos = userResult{tds, foundtds, errtds}
  
  result = formatOutputToJson(udetails,utodos)
  json.NewEncoder(w).Encode(result)
  
  jsonOutput, _ := json.MarshalIndent(result, "", "  ")
  println ("\nThe Merged output for the User details with Todo Summary is : \n", string(jsonOutput))
 
}

func readAndStoreUser (cntx context.Context,uid string) ([][]string) {
  
   url := fmt.Sprintf("https://dummyjson.com/users/%s", uid)
   req, err := http.NewRequestWithContext(cntx, http.MethodGet, url, nil)
    if err != nil {
        fmt.Println ("Error is : " , err)
        return [][]string{}
    }

    rsp, err := http.DefaultClient.Do(req)
    if err != nil {
        fmt.Println ("Error is : " , err)
        return [][]string{}
    }
    defer rsp.Body.Close()
    
    var inpinfo, uinfo [][]string
    
    err = json.NewDecoder(rsp.Body).Decode(&inpinfo) 
    if err != nil {
        fmt.Println ("Error is : " , err)
        return [][]string{}
    }
    
    println ("\nOriginal User file entries:")
    println ("-------------------------------")
  for _,row := range inpinfo {
    fmt.Println (row,"  ")
    fullname := ""
    var temp []string 
    
    //userdata := strings.Split(row,"," )
    for i, v := range row {
        if (i == 1 ) {
            fullname += strings.TrimSpace(v) + " "
            } else if (i == 2) {
                fullname += strings.TrimSpace(v)
            } else if (i == 3) {
                age,_ := strconv.Atoi(strings.TrimSpace(v)) 
                if (age > 50) {
                    temp = append(temp,"Veteran")
                    //print ("Veteran")
                } else {
                    temp = append(temp,"Rookie")
                    //print ("Rookie")
                }
            }
        
        switch i {
            case 0 :
              //print (strings.TrimSpace(v), ",")
              temp = append(temp,strings.TrimSpace(v))
            case 2 :
              //print (fullname, ",")
              temp = append(temp,fullname)
        }
    }
    println("")
    uinfo = append(uinfo,temp)
 }
 return uinfo
}

func readAndStoreTodo (cntx context.Context, uid string) ([][]string) {
  
    url := fmt.Sprintf("https://dummyjson.com/todos/users/%s", uid)
    req, err := http.NewRequestWithContext(cntx, http.MethodGet, url, nil)
    if err != nil {
        return nil
    }
    
    rsp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil
    }
    defer rsp.Body.Close()
    
    var inpinfo,tdinfo [][]string
    err = json.NewDecoder(rsp.Body).Decode(&inpinfo)
    if err != nil {
        return nil
    }
  
  println ("\nOriginal Todo file entries:")
  println ("-------------------------------")
  
  for _,tdrow := range inpinfo {
    fmt.Println(tdrow,"  ")
    var temp []string 
    sameuser := false
    var userindex int
    var tdesc string
    
    //tddata := strings.Split(row,"," )
    for i, v := range tdrow {
        // identify if the current user id is already present in tdinfo
        if len(tdinfo) > 0 && i == 0 {
            for itr := 0; itr < len(tdinfo) && !sameuser; itr++ {
                if (tdinfo[itr][0] == strings.TrimSpace(v)) {
                    sameuser = true
                    userindex = itr
                }
            }
        }
        // For same user update the existing entry in tdinfo else add new row in tdinfo from temp
        if sameuser { 
            if i == 1 {
                tdesc = strings.TrimSpace(v) // to be used for later if needed to update
            }
            if i == 2 && strings.TrimSpace(v) == "N" {
                x,_ := strconv.Atoi(tdinfo[userindex][2]) 
                x += 1
                tdinfo[userindex][2] = strconv.Itoa(x) 
                if tdinfo[userindex][2] == "1" {
                    tdinfo[userindex][1] = tdesc
                }
            }
        } else {
            if i == 2 && strings.TrimSpace(v) == "N" {
                temp = append(temp,"1") 
            } else if i == 2 && strings.TrimSpace(v) == "Y" {
                temp = append(temp,"0")
                temp[i-1] = ""
            } else {
                temp = append(temp,strings.TrimSpace(v))
            }
        }
      } //processing of one input line from the Todo file is finished
     
    println("")
    if !sameuser {
        tdinfo = append(tdinfo,temp)   
    }
  }
  return tdinfo
 }
 
 func findDetailsForUser (cntx context.Context, userId string, userDet [][]string) ([]string,bool,error) {
    userId = strings.TrimSpace(userId)
    for i := 0; i < len(userDet) ; i++ {
        select {
            case <- cntx.Done() :
                return nil, false, cntx.Err()
            default :
                if userDet[i][0] == userId {
                    /*
                    print ("\n\nThe matched user details are : ")
                    for j := 0 ; j < len(userDet[i]) ; j++ {
                        print (userDet[i][j], " # " )
                    } 
                    */
                    return userDet[i], true, nil
                }
        }
    }
    return nil, false, nil
 }
 
  func findTodoForUser (cntx context.Context, userId string, todoSummary [][]string) ([]string,bool,error) {
    userId =  strings.TrimSpace(userId)
    for i := 0; i < len(todoSummary) ; i++ {
        select {
            case <- cntx.Done() :
                 return nil, false, cntx.Err()
            default :
                if todoSummary[i][0] == userId {
                    /*
                    print ("\n\nToDo Summary for the matched user are : ")
                    for j := 0 ; j < len(todoSummary[i]) ; j++ {
                        print (todoSummary[i][j], " # " )
                    } 
                    */
                    return todoSummary[i],true,nil
                }
        }
    }
    return nil, false, nil
 }
 
 func formatOutputToJson (usrdtls userResult, usrtodos userResult) UserDetailsAndTodo {
     var jsnop UserDetailsAndTodo
     
     if (usrdtls.founduser && usrtodos.founduser) {
      println ("\n\nBoth user details and Todo Summary are successfully received")
      fmt.Println("User Details : ",usrdtls)
      fmt.Println("Todo Summary : ",usrtodos)
      jsnop = UserDetailsAndTodo { 
          Id : usrdtls.userdata[0],
          Full_name : usrdtls.userdata[1],
          Status : usrdtls.userdata[2],
          Pending_task_count : usrtodos.userdata[2],
          Next_urgent_task : usrtodos.userdata[1],
          Error_warning : "null",
        }
      } else if (usrdtls.founduser && !usrtodos.founduser) {
          if usrtodos.errfromfunc == context.DeadlineExceeded {
              println ("\n\nTransaction timed out while fetching ToDo Info for the user")
              fmt.Println("User Details : ",usrdtls)
              jsnop = UserDetailsAndTodo {
                  Id : usrdtls.userdata[0],
                  Full_name : usrdtls.userdata[1],
                  Status : usrdtls.userdata[2],
                  Pending_task_count : "null",
                  Next_urgent_task : "null",
                  Error_warning : "ToDo unavailable due to ToDo transaction got timed out",
                }
          } else {
              println ("\n\nOnly User details is successfully received, Todo Info is missing in the source data")
              fmt.Println("User Details : ",usrdtls)
              jsnop = UserDetailsAndTodo {
                  Id : usrdtls.userdata[0],
                  Full_name : usrdtls.userdata[1],
                  Status : usrdtls.userdata[2],
                  Pending_task_count : "null",
                  Next_urgent_task : "null",
                  Error_warning : "User ID is not available in the source Todo dataset",
                }
          }
      } else if (!usrdtls.founduser && usrtodos.founduser) {
          if usrdtls.errfromfunc == context.DeadlineExceeded {
              println ("\n\nTransaction timed out while fetching User details Info for the user")
              fmt.Println("ToDo Summary : ",usrtodos)
              jsnop = UserDetailsAndTodo{
                  Id : "null",
                  Full_name : "null",
                  Status : "null",
                  Pending_task_count : usrtodos.userdata[2],
                  Next_urgent_task : usrtodos.userdata[1],
                  Error_warning : "User details unavailable due to user details transaction got timed out",
                }
          } else {
              println ("\n\nOnly ToDo details is successfully received, User Details info is missing in the source data")
              fmt.Println("ToDo Summary : ",usrtodos)
              jsnop = UserDetailsAndTodo{
                  Id : "null",
                  Full_name : "null",
                  Status : "null",
                  Pending_task_count : usrtodos.userdata[2],
                  Next_urgent_task : usrtodos.userdata[1],
                  Error_warning : "User ID is not available in the source User Details dataset",
                }
          }
      } else {
          if usrdtls.errfromfunc == context.DeadlineExceeded && usrtodos.errfromfunc == context.DeadlineExceeded {
              println ("\n\nWhole Transaction timed out while fetching both User details info and ToDo info for the user")
          } else {
              println ("\n\nNone of User ID and Todo details are available in the dataset for the user")
          }
      }
    return jsnop
 }